# Comproto解析

### 流程分析

在comproto 有4种`handler`(对对象进行自定义处理，转化为可以被存储的值)

- ClassHandler
  
  通过`setHandlerMarker`方法给类的 `prototype` 属性添加 `mark`,这样的话此类的实例都可以被序列化

- CustomHandler
  
  通过`setHandlerMarker`方法给对象属性添加`mark`，然后通过`addCustomHandler`方法添加`序列化handler`

- Handler
  
  通过`addHandler`给添加序列化方法，有个`canHandler`方法可以判断对象是否可以被序列化（会添加到列表然后每次序列化时循环判断，会比较费性能，谨慎使用）

- TypeHandler(将对象转化成Uint8Array)
  
  > 只在内部进行处理，不对外
  
  当对象不可被用户添加的自定义`handler`处理，就会默认走这个Handler，首先它会通过`Object.prototy.toString`来判断对象类型，然后导航到对应的TypeHandler

# TypeHandler

> tag是用来确定数据类型的，有时候当数据量小的时候，也可以充当判断dataBuffer的依据

Uint8Array结构大体都是`tag + [lenBuffer] + dataBuffer`这种结构

### 举个例子：（其他的类型也是按照这种模式进行存储）

## String

先将string转化为u8a,判断buffer长度来确定tag

大于0小于32时使用`0xa0 - 0xbf`作为tag，后直接跟`dataBuffer`

大于32小于 255(0xFF)时使用`0xd9`作为tag, tag后一位字节存长度，再跟`dataBuffer`

大于255小于 65535(0xFFFF)时使用`0xda`作为tag,tag后两位字节存长度，再跟`dataBuffer`

大于65535(0xFFFF)时使用`0xdb`作为tag，tag后三位字节存长度，再跟`dataBuffer`

### tag表

> 因为tag只有一个字节，所以长度只有255。

```typescript
positive fixint -- 0x00 - 0x7f (0 ~ 127)
fix object -- 0x80 - 0x8f
fix array -- 0x90 - 0x9f
fix str -- 0xa0 - 0xbf
null -- 0xc0
undefined -- 0xc1
false -- 0xc2
true -- 0xc3
ArrayBufferView -- 0xc4
ArrayBufferView -- 0xc5
ArrayBufferView -- 0xc6
ext  -- 0xc7
(unuse)-- 0xc8
(unuse)-- 0xc9
bigInt -- 0xca
float 64 -- 0xcb
// 大于0整数
uint 8 -- 0xcc
uint 16 -- 0xcd
uint 32 -- 0xce
uint 32 -- 0xcf
// 小于0整数
int 8 -- 0xd0
int 16 -- 0xd1
int 32 -- 0xd2
int 64 -- 0xd3

(unuse) -- 0xd4
(unuse) -- 0xd5
(unuse) -- 0xd6
(unuse) -- 0xd7
(unuse) -- 0xd8

str 8 -- 0xd9
str 16 -- 0xda
str 32 -- 0xdb

array 16 -- 0xdc
array 32 -- 0xdd
object 16 -- 0xde
object 32 -- 0xdf
negative fixint -- 0xe0 - 0xff (-32 ~ -1)
```
